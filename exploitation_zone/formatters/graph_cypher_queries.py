import os
import json
from typing import Dict, List, Optional, Tuple
from neo4j import GraphDatabase
import pandas as pd
from datetime import datetime
import time

class GraphQueryAnalyzer:
    def __init__(self, uri: str, username: str, password: str):
        """Initialize Neo4j connection for querying"""
        self.driver = GraphDatabase.driver(uri, auth=(username, password))
        print("Connected to Neo4j database")
    
    def close(self):
        """Close Neo4j connection"""
        self.driver.close()
        print("Neo4j connection closed")
    
    def execute_query(self, query: str, parameters: Dict = None) -> List[Dict]:
        """Execute a Cypher query and return results"""
        with self.driver.session() as session:
            try:
                result = session.run(query, parameters or {})
                return [record.data() for record in result]
            except Exception as e:
                print(f"Query execution error: {e}")
                return []
    
    def get_database_stats(self) -> Dict:
        """Get comprehensive database statistics"""
        print("Gathering database statistics...")
        
        # Node counts
        node_query = """
        MATCH (n)
        RETURN labels(n)[0] as label, count(n) as count
        ORDER BY count DESC
        """
        
        # Relationship counts
        rel_query = """
        MATCH ()-[r]->()
        RETURN type(r) as relationship, count(r) as count
        ORDER BY count DESC
        """
        
        # Database overview
        overview_query = """
        MATCH (n)
        WITH count(n) as total_nodes
        MATCH ()-[r]->()
        WITH total_nodes, count(r) as total_relationships
        RETURN total_nodes, total_relationships
        """
        
        node_counts = self.execute_query(node_query)
        rel_counts = self.execute_query(rel_query)
        overview = self.execute_query(overview_query)[0]
        
        return {
            'overview': overview,
            'node_counts': node_counts,
            'relationship_counts': rel_counts
        }
    
    def find_similar_students(self, student_name: str, limit: int = 10) -> List[Dict]:
        """Find students similar to a given student"""
        query = """
        MATCH (s:Student {name: $student_name})-[r:SIMILAR_TO_PEER]->(similar:Student)
        RETURN similar.name as name, similar.major as major, similar.country as country,
               similar.age as age, r.matched_on as similarity_score
        ORDER BY r.matched_on DESC
        LIMIT $limit
        """
        return self.execute_query(query, {'student_name': student_name, 'limit': limit})
    
    def find_alumni_mentors(self, student_name: str, limit: int = 10) -> List[Dict]:
        """Find alumni mentors for a given student"""
        query = """
        MATCH (s:Student {name: $student_name})-[r:SIMILAR_TO_ALUMNI]->(a:Alumni)
        OPTIONAL MATCH (a)-[:WORKED_AT]->(c:Company)
        OPTIONAL MATCH (a)-[:STUDIED_AT]->(i:Institution)
        RETURN a.name as alumni_name, a.headline as headline,
               collect(DISTINCT c.name) as companies,
               collect(DISTINCT i.name) as institutions,
               r.matched_on as similarity_score
        ORDER BY r.matched_on DESC
        LIMIT $limit
        """
        return self.execute_query(query, {'student_name': student_name, 'limit': limit})
    
    def get_skill_analysis(self, skill_name: str) -> Dict:
        """Analyze a specific skill across students and alumni"""
        student_query = """
        MATCH (s:Student)-[:HAS_SKILL]->(sk:Skill {name: $skill_name})
        RETURN count(s) as student_count,
               collect(s.name)[0..5] as sample_students
        """
        
        alumni_query = """
        MATCH (a:Alumni)-[:HAS_SKILL]->(sk:Skill {name: $skill_name})
        OPTIONAL MATCH (a)-[:WORKED_AT]->(c:Company)
        RETURN count(a) as alumni_count,
               collect(DISTINCT c.name)[0..10] as top_companies
        """
        
        students = self.execute_query(student_query, {'skill_name': skill_name})[0]
        alumni = self.execute_query(alumni_query, {'skill_name': skill_name})[0]
        
        return {
            'skill': skill_name,
            'students_with_skill': students['student_count'],
            'alumni_with_skill': alumni['alumni_count'],
            'sample_students': students['sample_students'],
            'top_companies': alumni['top_companies']
        }
    
    def get_top_skills(self, limit: int = 20) -> List[Dict]:
        """Get most popular skills across students and alumni"""
        query = """
        MATCH (sk:Skill)
        OPTIONAL MATCH (s:Student)-[:HAS_SKILL]->(sk)
        OPTIONAL MATCH (a:Alumni)-[:HAS_SKILL]->(sk)
        WITH sk, count(DISTINCT s) as student_count, count(DISTINCT a) as alumni_count
        WHERE student_count > 0 OR alumni_count > 0
        RETURN sk.name as skill, student_count, alumni_count,
               student_count + alumni_count as total_count
        ORDER BY total_count DESC
        LIMIT $limit
        """
        return self.execute_query(query, {'limit': limit})
    
    def get_career_paths(self, degree: str, limit: int = 15) -> List[Dict]:
        """Get career paths for alumni with a specific degree"""
        query = """
        MATCH (a:Alumni)-[r:STUDIED_AT]->(i:Institution)
        WHERE toLower(r.degree) CONTAINS toLower($degree)
        OPTIONAL MATCH (a)-[w:WORKED_AT]->(c:Company)
        RETURN a.name as alumni_name, i.name as institution, r.degree as degree,
               collect(DISTINCT {company: c.name, title: w.title}) as career_path
        ORDER BY a.name
        LIMIT $limit
        """
        return self.execute_query(query, {'degree': degree})
    
    def get_institution_analysis(self, institution_name: str) -> Dict:
        """Analyze an institution's students and alumni"""
        student_query = """
        MATCH (s:Student)-[:STUDIES]->(i:Institution {name: $institution_name})
        RETURN count(s) as current_students,
               collect(DISTINCT s.major)[0..10] as popular_majors
        """
        
        alumni_query = """
        MATCH (a:Alumni)-[:STUDIED_AT]->(i:Institution {name: $institution_name})
        OPTIONAL MATCH (a)-[:WORKED_AT]->(c:Company)
        RETURN count(a) as alumni_count,
               collect(DISTINCT c.name)[0..15] as top_companies
        """
        
        students = self.execute_query(student_query, {'institution_name': institution_name})[0]
        alumni = self.execute_query(alumni_query, {'institution_name': institution_name})[0]
        
        return {
            'institution': institution_name,
            'current_students': students['current_students'],
            'alumni_count': alumni['alumni_count'],
            'popular_majors': students['popular_majors'],
            'top_companies': alumni['top_companies']
        }
    
    def get_networking_opportunities(self, student_name: str, limit: int = 10) -> List[Dict]:
        """Find networking opportunities for a student"""
        query = """
        MATCH (s:Student {name: $student_name})
        MATCH (s)-[:HAS_SKILL]->(common_skill:Skill)<-[:HAS_SKILL]-(a:Alumni)
        OPTIONAL MATCH (a)-[:WORKED_AT]->(c:Company)
        OPTIONAL MATCH (a)-[:STUDIED_AT]->(i:Institution)
        RETURN a.name as alumni_name, a.headline as headline,
               collect(DISTINCT common_skill.name) as shared_skills,
               collect(DISTINCT c.name) as companies,
               collect(DISTINCT i.name) as institutions
        ORDER BY size(shared_skills) DESC
        LIMIT $limit
        """
        return self.execute_query(query, {'student_name': student_name, 'limit': limit})
    
    def get_scholarship_recipients(self, scholarship_name: str = None) -> List[Dict]:
        """Get scholarship recipients, optionally filtered by scholarship name"""
        if scholarship_name:
            query = """
            MATCH (a:Alumni)-[:RECIPIENT_OF]->(s:Scholarship {name: $scholarship_name})
            OPTIONAL MATCH (a)-[:WORKED_AT]->(c:Company)
            RETURN a.name as alumni_name, a.headline as headline,
                   s.name as scholarship,
                   collect(DISTINCT c.name) as companies
            ORDER BY a.name
            """
            return self.execute_query(query, {'scholarship_name': scholarship_name})
        else:
            query = """
            MATCH (a:Alumni)-[:RECIPIENT_OF]->(s:Scholarship)
            RETURN s.name as scholarship, count(a) as recipient_count
            ORDER BY recipient_count DESC
            """
            return self.execute_query(query)
    
    def get_company_analysis(self, company_name: str) -> Dict:
        """Analyze alumni working at a specific company"""
        query = """
        MATCH (a:Alumni)-[w:WORKED_AT]->(c:Company {name: $company_name})
        OPTIONAL MATCH (a)-[:STUDIED_AT]->(i:Institution)
        OPTIONAL MATCH (a)-[:HAS_SKILL]->(sk:Skill)
        RETURN count(a) as alumni_count,
               collect(DISTINCT w.title) as job_titles,
               collect(DISTINCT i.name) as institutions,
               collect(DISTINCT sk.name)[0..15] as top_skills
        """
        result = self.execute_query(query, {'company_name': company_name})[0]
        
        return {
            'company': company_name,
            'alumni_count': result['alumni_count'],
            'job_titles': result['job_titles'],
            'feeder_institutions': result['institutions'],
            'top_skills': result['top_skills']
        }
    
    def find_study_groups(self, student_name: str, min_similarity: float = 0.2) -> List[Dict]:
        """Find potential study group members for a student"""
        query = """
        MATCH (s:Student {name: $student_name})
        MATCH (s)-[:STUDIES]->(i:Institution)<-[:STUDIES]-(peer:Student)
        MATCH (s)-[sim:SIMILAR_TO_PEER]->(peer)
        WHERE sim.matched_on >= $min_similarity
        RETURN peer.name as peer_name, peer.major as major,
               sim.matched_on as similarity_score,
               i.name as shared_institution
        ORDER BY sim.matched_on DESC
        """
        return self.execute_query(query, {
            'student_name': student_name,
            'min_similarity': min_similarity
        })
    
    def get_trending_skills_by_country(self, country: str, limit: int = 15) -> List[Dict]:
        """Get trending skills for students in a specific country"""
        query = """
        MATCH (s:Student)-[:LIVES_IN]->(c:Country {name: $country})
        MATCH (s)-[:HAS_SKILL]->(sk:Skill)
        RETURN sk.name as skill, count(s) as student_count
        ORDER BY student_count DESC
        LIMIT $limit
        """
        return self.execute_query(query, {'country': country, 'limit': limit})
    
    def export_to_csv(self, query_results: List[Dict], filename: str):
        """Export query results to CSV"""
        if query_results:
            df = pd.DataFrame(query_results)
            df.to_csv(filename, index=False)
            print(f"Results exported to {filename}")
        else:
            print("No data to export")
    
    def run_custom_query(self, query: str, parameters: Dict = None) -> List[Dict]:
        """Run a custom Cypher query"""
        print(f"Executing custom query...")
        return self.execute_query(query, parameters)

def print_results(results: List[Dict], title: str = "Query Results"):
    """Pretty print query results"""
    print(f"\n{'='*50}")
    print(f"{title}")
    print(f"{'='*50}")
    
    if not results:
        print("No results found.")
        return
    
    for i, result in enumerate(results, 1):
        print(f"\n{i}. {result}")

def main():
    # Neo4j connection details
    NEO4J_URI = "bolt://localhost:7687"
    NEO4J_USERNAME = "neo4j"
    NEO4J_PASSWORD = "password"
    
    # Initialize query analyzer
    analyzer = GraphQueryAnalyzer(NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD)
    
    try:
        # Example usage - uncomment the queries you want to run
        
        # 1. Get database statistics
        print("=== DATABASE STATISTICS ===")
        stats = analyzer.get_database_stats()
        print(f"Total Nodes: {stats['overview']['total_nodes']}")
        print(f"Total Relationships: {stats['overview']['total_relationships']}")
        print("\nNode Counts:")
        for node in stats['node_counts']:
            print(f"  {node['label']}: {node['count']}")
        
        # 2. Get top skills
        print("\n=== TOP 10 SKILLS ===")
        top_skills = analyzer.get_top_skills(10)
        for skill in top_skills:
            print(f"{skill['skill']}: {skill['student_count']} students, {skill['alumni_count']} alumni")
        
        # 3. Example: Find similar students (replace with actual student name)
        # similar_students = analyzer.find_similar_students("John Doe", 5)
        # print_results(similar_students, "Similar Students")
        
        # 4. Example: Find alumni mentors (replace with actual student name)
        # mentors = analyzer.find_alumni_mentors("John Doe", 5)
        # print_results(mentors, "Potential Alumni Mentors")
        
        # 5. Example: Analyze a specific skill
        skill_analysis = analyzer.get_skill_analysis("Python")
        print(f"\n=== PYTHON SKILL ANALYSIS ===")
        print(f"Students with Python: {skill_analysis['students_with_skill']}")
        print(f"Alumni with Python: {skill_analysis['alumni_with_skill']}")
        
        # 6. Example: Get career paths for Computer Science graduates
        # career_paths = analyzer.get_career_paths("Computer Science", 10)
        # print_results(career_paths, "Computer Science Career Paths")
        
        # Company analysis
        # company_analysis = analyzer.get_company_analysis("Google")
        # print(f"\n=== GOOGLE ANALYSIS ===")
        # print(company_analysis)
        
        # 8. 
        custom_query = """
        MATCH (s:Student)-[:HAS_SKILL]->(sk:Skill)<-[:HAS_SKILL]-(a:Alumni)
        RETURN sk.name as skill, count(DISTINCT s) as students, count(DISTINCT a) as alumni
        ORDER BY students + alumni DESC
        LIMIT 10
        """
        custom_results = analyzer.run_custom_query(custom_query)
        print_results(custom_results, "Skills Shared by Students and Alumni")
        
        # 9. Export example
        # analyzer.export_to_csv(top_skills, "top_skills.csv")
        
    except Exception as e:
        print(f"Error running queries: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        analyzer.close()

if __name__ == "__main__":
    main()